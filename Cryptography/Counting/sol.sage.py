from pwn import *

# This file was *autogenerated* from the file exp_counting.sage
from sage.all_cmdline import *   # import sage library
from Crypto.Util.number import bytes_to_long, long_to_bytes
_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1337 = Integer(1337)
from sage.all import *

def gcd(a, b): 
    while b:
        a, b = b, a % b
    return a.monic()

#able to get M1 and M2 when thery are encrypted under the same (e, N) and a linear relation between them is know, in our case we know that changing the counter
#will lead to a bit turned up in the message so an increase of a power of 2
def franklinreiter(C1, C2, e, N, a):
    P = PolynomialRing(Zmod(N), names=('X',)); (X,) = P._first_ngens(1)
    g1 = (X + a)**e - C1
    g2 = X**e - C2
    print("Done")
    result = -gcd(g1, g2).coefficients()[_sage_const_0 ]
    return hex(int(result))[_sage_const_2 :]

e = _sage_const_1337 

con = remote("52.59.124.14", 10008)
con.recvline()
N = int(con.recvline().decode()[:-1])
con.recvline()
C1 = int(con.recvline().decode()[:-1])
con.recv()
con.sendline(b"1")
C2 = int(con.recvline().decode()[:-1])
con.recv()
token = b""
print(N, C1, C2)

pos = 288+8*20 #hope that flag is at least 20 char

#bruteforce the bit that turned up until a match is found, because i don't know the exact lenght of the flag
while True:
    a = -2**pos
    mess = franklinreiter(C1, C2, e, N, a)
    mess = bytes.fromhex(mess)
    if b'token' in mess:
        print("found")
        token = mess[52:]
        print(token)
        con.sendline(token)
        con.interactive()
    pos += 8

#ENO{th3_s0lut1on_i5_n0t_th4t_1337}